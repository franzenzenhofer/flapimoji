<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flapimoji - Emoji Flappy Bird</title>
<style>

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
}

    body { margin: 0; overflow: hidden; background-color: #00f; }
    #grid { display: grid; gap: 1px; width: 100vw; height: 100vh; }
    .cell { width: 16px; height: 16px; display: flex; justify-content: center; align-items: center; }
</style>
<style>
    #tabToFlap {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2em;
        z-index: 1000;
        display: none;
    }
</style>
</head>
<body>
<div id="grid"></div>
<div id="tabToFlap">ðŸ‡¹â€‹ðŸ‡¦â€‹ðŸ‡§â€‹<br>ðŸ‡¹â€‹ðŸ‡´â€‹<br>ðŸ‡«â€‹ðŸ‡±â€‹ðŸ‡¦â€‹ðŸ‡µ</div>

<script type="module">// Calculate grid size based on viewport size
    const calculateGridSize = () => {
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        return { columns: Math.floor(vw / 17), rows: Math.floor(vh / 17) + 3 };
    };
    
    // Initial state
    const initialState = {
        bird: { x: 3, y: Math.floor(window.innerHeight / 34) },
        towers: [],
        gridSize: calculateGridSize()
    };


    
    // Update bird's position
    const updateBird = (bird, flap, gridSize, fast = false) => ({
        x: bird.x,
        y: Math.max(0, Math.min(bird.y + (flap ? -1 : 1), gridSize.rows - 1))
    });
    
// Initialize a variable to track horizontal distance to next tower
let nextTowerDistance = 4;

const updateTowers = (towers, gridSize, birdY) => {
  const updatedTowers = towers.filter(tower => tower.x >= 0).map(tower => ({ ...tower, x: tower.x - 1 }));
  
  // Randomly set the distance for the next tower to be created.
  nextTowerDistance = Math.floor(Math.random() * 3) + 5;

  if (!towers.length || towers[towers.length - 1].x < gridSize.columns - nextTowerDistance) {
    let gapPosition;
    if (birdY != null) {
      gapPosition = Math.max(4, Math.min(gridSize.rows - 4, birdY + Math.floor(Math.random() * 7) - 3));
    } else {
      gapPosition = Math.floor(Math.random() * (gridSize.rows - 10)) + 5;
    }
    updatedTowers.push({ x: gridSize.columns - 1, gapPosition });
  }
  return updatedTowers;
};

    // Check for collisions
    const checkCollision = (bird, towers, gridSize) => 
        bird.y < 0 || bird.y >= gridSize.rows ||
        towers.some(tower => (
            tower.x === bird.x &&
            (bird.y <= tower.gapPosition - 3 || bird.y >= tower.gapPosition + 3)
        ));
    
    // Render the game state
    const render = (state) => {
        const gridElement = document.getElementById('grid');
        gridElement.style.gridTemplateColumns = `repeat(${state.gridSize.columns}, 16px)`;
        gridElement.style.gridTemplateRows = `repeat(${state.gridSize.rows}, 16px)`;
        gridElement.innerHTML = '';
        Array.from({ length: state.gridSize.rows }, (_, rowIdx) =>
            Array.from({ length: state.gridSize.columns }, (_, colIdx) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                if (colIdx === state.bird.x && rowIdx === state.bird.y) {
                    cell.innerText = 'ðŸ¥';
                } else if (state.towers.some(tower => 
                    colIdx === tower.x && (rowIdx <= tower.gapPosition - 3 || rowIdx >= tower.gapPosition + 3)
                )) {
                    cell.innerText = 'ðŸŸ©';
                } else {
                    cell.innerText = 'ðŸŸ¦';
                }
                gridElement.appendChild(cell);
            })
        );
    };
    
    let gameStarted = false;
    let currentState = {...initialState};
    let gameLoopTimeout;

    
    const handleFlap = (fast = false) => {
        if (!gameStarted) {
            gameStarted = true;
            document.getElementById('tabToFlap').style.display = 'none';  // Hide "TAB TO FLAP"
            gameLoop(currentState, true);
        } else {
            currentState = { ...currentState, bird: updateBird(currentState.bird, true, currentState.gridSize, fast) };
        }
    };
    
    const handleDrop = () => {
        currentState = { ...currentState, bird: updateBird(currentState.bird, false, currentState.gridSize, true) };
    };
    
    const gameLoop = (state, flap = false) => {
        clearTimeout(gameLoopTimeout);
        currentState = { ...state };
        const updatedBird = updateBird(currentState.bird, flap, currentState.gridSize);
  const updatedTowers = updateTowers(currentState.towers, currentState.gridSize, updatedBird.y);

        if (!checkCollision(updatedBird, updatedTowers, currentState.gridSize)) {
            render({ ...currentState, bird: updatedBird, towers: updatedTowers });
            currentState = { ...currentState, bird: updatedBird, towers: updatedTowers };
            gameLoopTimeout = setTimeout(() => gameLoop(currentState), 500);
        } else {
            render({ ...currentState, bird: updatedBird, towers: updatedTowers });
            const userChoice = window.confirm("Game Over - Play Again?");
if (userChoice) {
  currentState = {...initialState};
  gameStarted = false;
  render(initialState);
  clearTimeout(gameLoopTimeout);
}

        }
    };    // Removed handleDescendStart and handleDescendStop functions
    
    let lastTouchTime;
    
    const handleInteraction = (isMobile, fast = false) => {
        if (isMobile && lastTouchTime) {
            const currentTime = new Date().getTime();
            if (currentTime - lastTouchTime < 500) {
                return;  // Avoid mobile click collision
            }
        }
        handleFlap(fast);
        lastTouchTime = new Date().getTime();
    };

    // Updated event listener for clicks
    document.body.addEventListener('click', () => handleInteraction(false, true));

    // Updated event listener for touch events
    document.body.addEventListener('touchstart', (e) => {
        lastTouchTime = new Date().getTime();
        handleInteraction(true, true);
    });

    // Updated event listener for keyboard events
    document.addEventListener('keydown', (event) => {
        if (event.code === 'ArrowUp' || event.code === 'Space') {
            handleInteraction(false, true);
        }
    });

    
    render(initialState);

    if (!gameStarted) {
        document.getElementById('tabToFlap').style.display = 'block';
    } else {
        document.getElementById('tabToFlap').style.display = 'none';
    }
    
</script>
</body>
</html>
